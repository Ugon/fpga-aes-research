\section{Throughput optimized architecture}
\label{sec:throughput-optimized-architecture}

Throughput of AES encryption module is optimized by utilizing pipelining. To use this technique the design needs to be split into stages. To maximize benefits that pipelining brings signal propagation time through all stages needs to be roughly the same. Authors of \cite{vlsi} partitioned their design based on critical path length. My testing shows that this approach is suboptimal, and higher frequencies can be achieved by partitioning the design in a way that combinatorial logic for each output bit of a stage has no more than 4 inputs. This is due to how FPGA technology works and will be explained in more detail this section.

% \begin{table}[!h]
    % \label{table:sub-bytes-crit-path}
	% \centering
	% \begin{tabular}{| l | l |}
	% \hline
    % \textbf{Operation} & \textbf{Critical path} \\ \hline
% 
    % Multiplication by constant $\phi$ in $GF(2^2)$ & 1 XOR \\ \hline
% 
    % Multiplication by constant $\lambda$ in $GF(2^4)$ & 2 XOR \\ \hline
% 
    % Multiplication in $GF(2^2)$ & 2 XOR + 1 AND \\ \hline
% 
    % Multiplication in $GF(2^4)$ & 4 XOR + 1 AND \\ \hline
% 
    % Squaring in $GF(2^4)$ & 2 XOR \\ \hline
% 
    % Multiplicative inversion in $GF(2^4)$ & 3 XOR + 2 AND \\ \hline
% 
    % Mapping from $GF(2^8)$ to $GF((2^4)^2)$ & 4 XOR \\ \hline
% 
    % Mapping from $GF((2^4)^2)$ to $GF(2^8)$ + AES affine transformation & 4 XOR \\ \hline
% 
    % \end{tabular}
    % \caption{Critical path lengths for operations in SubBytes transformation}
% \end{table}
% 
% \begin{table}[!h]
	% \centering
	% \begin{tabular}{| l | l |}
	% \hline
    % \textbf{Transformation} & \textbf{Critical path} \\ \hline
	% MixColumns & 3 XOR \\ \hline
	% AddRoundKey & 1 XOR \\ \hline
	% ShiftRows & 0 \\ \hline
    % \end{tabular}
    % \caption{Critical path lengths for MixColumns, ShiftRows and AddRoundKey transformations}
% \end{table}
% 

\subsection{Low level FPGA chip analysis}
\label{sec:low-level-fpga}
To optimize a circuit for high frequency operation it is necessary to understand how FPGA technology works on low level. FPGA chips' archirectures may slightly vary, here we will focus on architecture of the chip that I used for testing - Altera Cyclone V \cite[Chapter 1]{altera-vol1}. For simplicity only elements relevant to this design will be covered here, detailed documentation is available in Cyclone V Handbook \cite{altera-vol1}.

FPGA chips consist of LABs (Logic Array Blocks), each of which contains 10 ALMs (Adaptive Logic Modules). ALMs are elements that make it possible to place arbitrary circuits in FPGA - they can be programmed to implement combinatorial logic functions, arithmetic functions, and registers.

Combinatorial logic is implemented in ALMS using LUTs (LookUp Tables) which contain high speed ROM memory. This memory is programmed with precomputed outputs for every possible combination of logic levels of input signals. LUTs take combinatorial logic inputs and use them as addresses to corresponding memory bits. Output of LUT is a bit read from memory which corresponds to provided inputs. An important consequence of this design feature is that for a LUT with N inputs it is irrelevant how complex the logic to be implemented is - as long as it has no more than N inputs it will always perform the same. This is because all outputs are precomputed and all it takes to determine the output is to read it from memory. If desired combinatorial logic has more than N inputs multiple LUTs will be required.

In Cyclone V chips each ALM contains two LUTs and four registers (D flip-flops). The registers, however, are wired in such a way that only two are relevant for this design - other two could be utilised if ALMs were used to implement arithmetic logic, which does not happen in AES encryption. LUTs in Cyclone V ALMs are capable of implementing different combinations of combinatorial logic, for this design the relevant combinations are:
\begin{itemize}
\item one 6-input LUT per ALM - uses up to 1 register, leaves at least one register unused
\item two 4-input LUTs per ALM - uses up to 2 registers
\end{itemize}
Combinatorial logic outputs can either be registered in the ALM they were calculated in or routed to another ALM without registering. For fastest operation in most cases it is desired to register them in the same ALM, because routing inside ALM is a lot faster than between ALMs. Routing outputs without registering is necessary when combinatorial logic has more inputs than a single ALM supports, or to move the register closer to other parts of the design to balance routing delays between different parts of the design.

% Conducted tests showed that for AES encryption maximum frequency was higher for designs using only 4-input LUTs. Analysis of compilation reports showed that using 6-input LUTs resulted in overall increased number or resources used, which resulted in longer routing paths between parts of the design, which ultimately slowed it down. This makes sence, because for 4-input LUTs ALMs are used more efficiently - more combinatorial logic could be implemented, and both registers could be used. The leftover register when using 6-input operation mode was observed not to be used often, because other signals were typically registered in same ALMs they were calculated in.
Conducted tests showed that for AES encryption maximum frequency was higher for designs using only 4-input LUTs. Analysis of compilation reports showed that using 6-input LUTs resulted in paths with longer signal propagarion time, which slowed the design it down. This makes sence, because for 4-input LUTs ALMs are used more efficiently - more combinatorial logic could be implemented, and both registers could be used. The leftover register when using 6-input operation mode was observed not to be used often, because other signals were typically registered in same ALMs they were calculated in.

Another important aspect of working with FPGA is that \textit{Place and Route} compilation phase, which is responsible of finding optimal placement of the design in FPGA chip, tackles an NP-hard problem. This phase therefore uses heuristics to produce an approximation of best possible solution. It is possible that final placement of the design will be different for each compilation attempt. This behaviour was observed during testing, but maximum frequency for given design remained stable between compilation attempts. The longest routes for each compilation were different every time, but leading trends were similar (eg. most routes from top 10 failing ones were between pipelined stages X and Y).



\subsection{Analysis of pipelied stages of equal critical path lengths}
As an entry point for my research I implemented the circuit proposed in \cite[Fig. 11]{vlsi} (for r=7 pipeline stages). Testing of this design showed that all transformations individualy could run at frequencies exceeding 500MHz (close to or at testing circuits max frequency of 530MHz). One full round could run at this frequency as well, but adding more consecutive rouds resulted in decrease of frequency due to FPGA resource congestion resulting in longer routing paths. Full AES encryption circuit, which consists of 15 rounds, was capable of operating at \textbf{375MHz} and consumes 15123 ALM resources.

Analysis of paths with longest propagation time presented in compilation report showed that typically they consisted of two or more ALMs used for calculating combinatorial logic. This was due to the fact that this design used pipelining stages which for calculating each output bit required more than 6 inputs. This forced utilising multiple ALMs between registers, which resulted in long routing delays.

The conclusions of this research were:
\begin{itemize}
\item To achieve higher frequency it was necessary to split the design into shorter pipelining stages.
\item Critical path length calculated as number of layers of logical gates is irrelevant (sec. \ref{sec:low-level-fpga}).
\item What is relevant is the number of input signals required for calculating each bit of stage output, which should be no higher than 6.
\item Routing delays are a significant factor contributing to maximum achievable frequency.
\item Reducing number of LUTs between registers is critical for high performance.
\end{itemize}

% Analysis of compilation reports showed that paths with longest signal propagation time, which were responsible for limiting maximum achievable frequency, 



% SubBytes transformation is by far the most complex one and it should be split into multiple pipelined stages. MixColumns and AddRoundKey have short critical paths (3 and 1 respectively) and can be combined into a single stage with critical path of 4. ShiftRows only rearranges order of bits in AES state without using any logic gates, so it can be joined with other operations to form a stage.

% Performance testing indicated that stages with critical paths of 6 gates would be short enough to be able to operate at over 500MHz, which is enough to fully utilize used testing framework. It is also convenient, as such stage length makes it possible to use all operations (\ref{table:sub-bytes-crit-path}) without splitting them. It is worth noting, that given an FPGA chip capable of operating at higher frequencies, pipelining stages could be made shorter than what is considered here (critical path of 6).

% Each AES round is split into 6 pipeline stages as shown in fig. \ref{fig:round-split}.


\subsection{Design of optimal pipelining stages}
\label{sec:pipeline-stages-design}

First approach to optimization was to split pipelining stages so that thay used 4-input as well as 6-input LUTs. This approach resulted in increased performance, but analysis of compilation reports showed that paths with longest signal propagation time typically led through ALMs utilising 6-input operation mode. The circuit was therefore further redesigned to take advantage of only 4-input operation mode. Final design was capable of operating at \textbf{406MHz}, which is the highest achieved frequency for AES encryption observed in this research. The number of logic elements as reported by compiler for this design was \textbf{22411} (excluding 806 elements required for testing circuit).

This section will describe in detail how each operation in AES algorithm (sec. \ref{sec:aes-algorithm}) can be split into stages taking advantage of only 4-input LUT operation mode. To utilise this mode each registered output bit needs to depend on no more than 4 inputs.

% \paragraph{Top level design of SubBytes transformation}\mbox{}\\


\paragraph{Mapping $f(x)$ from $GF(2^8)$ to $GF((2^4)^2)$}\mbox{}\\
Output bits of this operation depend on as much as 7 input bits, therefore to make it use only 4-input LUTs it is necessary to split it into two substages (\ref{eg:f-split}) (fig. \ref{fig:f-split}) -- $f_a$ (\ref{eq:mul_delta_a}) and $f_b$ (\ref{eq:mul_delta_b}).

\begin{equation}
\label{eg:f-split}
f(x) = f_b \circ f_a(x)
\end{equation}

\begin{figure}[!h]
\centering
\includegraphics[scale=4]{f-split}
\caption{Decomposition of mapping $f(x)$ from $GF(2^8)$ to $GF((2^4)^2)$ into two stages}
\label{fig:f-split}
\end{figure}

\begin{equation}
\label{eq:mul_delta_a}
\begin{aligned}
b_{a0}    &= b_0                    \\
b_{a1}    &= b_1                    \\
b_{a2}    &= b_2                    \\
b_{a4}    &= b_4                    \\
b_{a5}    &= b_5                    \\
b_{a6}    &= b_6                    \\
b_{a7}    &= b_7                    \\
b_{a23}   &= b_2 + b_3              \\
b_{a567}  &= b_5 + b_6 + b_7        \\
b_{a1234} &= b_1 + b_2 + b_3 + b_4
\end{aligned}
\end{equation}

\begin{equation}
\label{eq:mul_delta_b}
\begin{aligned}
b'_0 &= b_{a0} + b_{a1} + b_{a6}           \\
b'_1 &= b_{a1} + b_{a4} + b_{a6}           \\
b'_2 &= b_{a7} + b_{a1234}                 \\
b'_3 &= b_{a1} + b_{a2} + b_{a6} + b_{a7}  \\
b'_4 &= b_{a1} + b_{a5} + b_{a7} + b_{a23} \\
b'_5 &= b_{a5} + b_{a7} + b_{a23}          \\
b'_6 &= b_{a6} + b_{a7} + b_{a1234}        \\
b'_7 &= b_{a5} + b_{a7}                    
\end{aligned}
\end{equation}

In SubBytes transformation after mapping $f(x)$ from $GF(2^8)$ to $GF((2^4)^2)$ high and low words of the result are xored together. This operation can be performed concurently with $f_b(x)$ mapping to avoid creating a separate stage only for a xor operation.

\begin{equation}
\begin{aligned}
f_{xor}(x) &= f(x)_{0123} + f(x)_{4567} \\
f_{xor}(x) &= f_{xorb} \circ f_a(x)
\end{aligned}
\end{equation}

\begin{equation}
\label{eq:mul_delta_xor}
\begin{aligned}
b_{xorb0} &= b_{a0} + b_{a23} + b_{a567}       \\
b_{xorb1} &= b_{a1234} + b_{567}               \\
b_{xorb2} &= b_{a6}                            \\
b_{xorb3} &= b_{a1} + b_{a2} + b_{a5} + b_{a6}
\end{aligned}
\end{equation}

From equations (\ref{eq:mul_delta_a}), (\ref{eq:mul_delta_b}) and (\ref{eq:mul_delta_xor}) it is apparent that each stage output bit depends on no more than 4 inputs.




\paragraph{Mapping $f^{-1}(x)$ from $GF((2^4)^2)$ to $GF(2^8)$ combined with AES affine transformation}\mbox{}\\
Analoguously to mapping $f(x)$ from $GF(2^8)$ to $GF((2^4)^2)$, mapping $f^{-1}(x)$ from $GF((2^4)^2)$ to $GF(2^8)$ combined with affine transformation (\ref{sec:comb-theory}) (\ref{eq:fa-split}) (fig. \ref{fig:fa-split}) should be split into two substages --  $f^{-1}_a$ (\ref{eq:mul_delta_inf_a}) and $f^{-1}_b$ (\ref{eq:mul_delta_inf_b}).

\begin{equation}
\label{eq:fa-split}
\begin{aligned}
f^{-1}(x) &= f_b^{-1}(x) \circ f_a^{-1}(x) \\
\end{aligned}
\end{equation}

\begin{figure}[!h]
\centering
\includegraphics[scale=4]{fa-split}
\caption{Decomposition of mapping $f^{-1}(x)$ from $GF((2^4)^2)$ to $GF(2^8)$ combined with AES affine transformation into two stages}
\label{fig:fa-split}
\end{figure}


\begin{equation}
\label{eq:mul_delta_inf_a}
\begin{aligned}
b_{a0}    &= b_0                    \\
b_{a7}    &= b_7                    \\
b_{a23}   &= b_2 + b_3              \\
b_{a012}  &= b_0 + b_1 + b_2        \\
b_{a023}  &= b_0 + b_2 + b_3        \\
b_{a456}  &= b_4 + b_5 + b_6        \\
b_{a0147} &= b_0 + b_1 + b_4 + b_7  \\
b_{a27N}  &= b_2 + b_7 + 1          \\
b_{a67N}  &= b_6 + b_7 + 1            
\end{aligned}
\end{equation}

\begin{equation}
\label{eq:mul_delta_inf_b}
\begin{aligned}
b'_0 &= b_{a012} + b_{67N}           \\
b'_1 &= b_{a0} + b_{a7} + 1          \\
b'_2 &= b_{a023} + b_{a456}          \\
b'_3 &= b_{a012}                     \\
b'_4 &= b_{a0147}                    \\
b'_5 &= b_{a27N}                     \\
b'_6 &= b_{a456} + b_{a7} + 1        \\
b'_7 &= b_{a23} + b_{a7}                    
\end{aligned}
\end{equation}

From equations (\ref{eq:mul_delta_inf_a}) and (\ref{eq:mul_delta_inf_b}) it is apparent that each stage output bit depends on no more than 4 inputs. Note that $xor$ with $1$ value is merely a $not$ operation, and it does not increase input count. It is also true that all outputs of $f_b^{-1}(x)$ stage depend on no more than 2 inputs, so they can be xored with 2 other independent inputs to form a stage, which is important for a stage in key expansion pipeline.




\paragraph{Multiplicative inversion in $GF(2^4)$}\mbox{}\\
This operation has only 4 inputs, so it is can already be implemented using a 4-input LUT.

\paragraph{Multiplication by constant $\phi$ in $GF(2^2)$}\mbox{}\\
This operation has only 2 inputs, so it is can already be implemented using a 4-input LUT. 

\paragraph{Multiplication by constant $\lambda$ in $GF(2^4)$}\mbox{}\\
This operation has only 4 inputs, so it is can already be implemented using a 4-input LUT. Moreover, it is only used as part of SubBytes transformation directly after squaring in $GF(2^4)$. Because squaring takes only 4 inputs, and multiplication by $\lambda$ operates only on output of squaring, those two operations can be combined into single stage. Such merging only increases length of critical path of the stage (which is irrelevant) but does not increase number of inputs, which is still 4.


\paragraph{Multiplication in $GF(2^2)$}\mbox{}\\
This operation has only 4 inputs, so it is can already be implemented using a 4-input LUT. Every output depends on at most 3 inputs, so it is possible to xor each of them with a signal that does not depend on anything (was just registered).

\paragraph{Multiplication in $GF(2^4)$}\mbox{}\\
This operation has 8 inputs, so it is necessary to split it into two stages (fig. \ref{fig:mul-gf4-split}).

\begin{figure}[!h]
\centering
\includegraphics[scale=4]{mul-gf4-split}
\caption{Decomposition of multiplication in $GF(2^4)$ into two stages}
\label{fig:mul-gf4-split}
\end{figure}

This split uses only 4-input LUT operation mode, because:
\begin{itemize}[nolistsep]
\item Each bit of signals $a$ and $d$ depends on no more than 3 input signals, because on their paths there are only multiplications in $GF(2^2)$, which have this property. 
\item Each bit of signals $b$ and $c$ depends only on 2 input signals, because they are xors.
\item Each bit of signal $e$ depends on no more than 2 input signals, because this is a property of multiplication by $\phi$.
\item Each bit of signal $f$ depends on no more than 3 input signals, because this is a property of multiplications in $GF(2^2)$.
\item Each bit of signal $g$ depends on no more than 4 input signals, because signals from $f$ are xored with independent signals.
\item Each bit of signal $h$ depends on no more than 3 input signals, because signals from $e$ are xored with independent signals.
\end{itemize}


\paragraph{Squaring in $GF(2^4)$}\mbox{}\\
This operation has only 4 inputs, so it is can already be implemented using a 4-input LUT.


\paragraph{ShiftRows transformation}\mbox{}\\
This transformation does not do combinatorial logic and thus can be joined with any other operation to form a stage.


\paragraph{MixColumns transformation}\mbox{}\\
Lets first notice that some output bits of multiplication by $\{02\}_{16}$ depend on 2 input signals, all of which are already $xors$. This means that outputs of multiplication blocks already depend on $2 * 2 = 4$ signals. Those outputs are than xored again, which results in exceeding 4-input limit. MixColumns transformation, therefore, needs to be split into two stages. It can be done as shown in figure \ref{fig:mix-columns-split}.

\begin{figure}[!h]
\centering
\includegraphics[scale=3]{mix-columns-split}
\caption{Decomposition of MixColumns transformation into two stages}
\label{fig:mix-columns-split}
\end{figure}

Those stages can be implemented using only 4-input LUTs, because:
\begin{itemize}[nolistsep]
\item Each bit of signals marked $a$ depends on 2 input signals.
\item Each bit of signals marked $b$ depends on 3 input signals.
\item Each bit of signals marked $c$ depends on no nore than 2 input signals.
\item Each bit of signals marked $d$ depends on no nore than 3 input signals.
\end{itemize}

Note that all output bits depend on no more than 3 input signals, which means that they can be xored with other independent inputs in one stage. This is useful for combining it with AddRoundKey transformation.


\paragraph{AddRoundKey transformation}\mbox{}\\
This transformation consists only of a xor gate, which means that it can be combined into one stage with MixColumns.


\subsection{Final design of throughput-optimized AES encryption circuit}
Taking all points presented in section \ref{sec:pipeline-stages-design} into consideration, it follows that a pipelied circuit using only 4-input LUTs can be implemeted according to diagram in figure \ref{fig:high-speed-pipe-full}.


\begin{sidewaysfigure}
\label{fig:high-speed-pipe-full}
\centering
\includegraphics[scale=2]{high-speed-pipe-full}
\caption{Throughput optimized AES encryption pipelined circuit}
\end{sidewaysfigure}


